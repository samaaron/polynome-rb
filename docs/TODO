First phase - basic bridge mode

Polynome acts as a basic bridge with one Virtual Monome on the Table which forwards all messages
to and from the real monome and application (such as MLR)

  [*]  - App registers that it wants Polynome to enter test mode
  [*]  - App tells Polynome where it wants the test OSC messages to be sent to
          i.e. /polynome/internal/test/on "localhost", 1234  ; for internal test mode
  [*]  - Polynome reads from a config file where it should send regular OSC output
  [*]  - A VM for App is created with the correct model and cable orientation
  [ ]  - Create a test output thread with a queue which it pulls messages from and logs
  [*]  - Give each VM its own listener so apps can send messages to the VM
  [*]  - Give each VM its own sender so it can send output to the real monome
  [ ]  - Create a debug mode for VMs for which all debug messages are sent to the ThreadedLogger
  [*]  - Apps VM is placed on the Table
  [ ]  - Apps VM listens for messages
  [ ]  - App sends OSC messages to Apps VM
  [ ]  - Polynome filters out Monome messages and sends them to the Monome
  [ ]  - Polynome sends all (including filtered) OSC messages back to S on the appropriate ports
  [ ]  - Polynome sends all filtered messages onto the monome
  [ ]  - Try Polymer with MLR
  [ ]  - Move the test response code from Rack to OSCListener

* echo messages to monome
* create a thread and listening port for virtual monomes
* echo messages from currently active application to monome
* create switcher to switch between virtual monome screens (slide in / out)
* receive more advanced messages - boxes, shapes, patterns etc.
* split a monome into separate monomes (e.g. the 256 can become two 128s)
